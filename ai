---main.js
//----------------------------------------------------CONFIG
let model = tf.sequential(); //activation: "sigmoid"
model.add(
  tf.layers.dense({
    inputShape: [2],
    units: 1,
    useBias: true
  })
);
model.add(tf.layers.dense({ units: 1, useBias: true }));
model.compile({
  optimizer: tf.train.sgd(0.2),
  loss: "meanSquaredError"
});
//----------------------------------------------------PREPARE DATA
let data = {
  input: [
    4,
    3,
    23,
    4,
    3,
    3,
    3,
    5,
    4,
    34,
    43,
    3,
    3,
    6,
    6,
    542,
    3,
    7,
    76,
    8,
    6,
    76,
    7
  ],
  input2: [
    6,
    5,
    32,
    1,
    5,
    7,
    7,
    3,
    43,
    3,
    0,
    9,
    8,
    3,
    1,
    3,
    3,
    7,
    7,
    5,
    8,
    7,
    4
  ],
  output: [
    24,
    15,
    736,
    4,
    15,
    21,
    21,
    15,
    172,
    102,
    0,
    27,
    24,
    18,
    6,
    1626,
    9,
    49,
    532,
    40,
    48,
    532,
    28
  ]
};
let tensorData = tf.tidy(() => {
  let shuffledData = data.output.map((output, i) => [
    data.input[i],
    data.input2[i],
    output
  ]);
  tf.util.shuffle(shuffledData);

  let inputArray = shuffledData.map(el => [el[0], el[1]]);
  let outputArray = shuffledData.map(el => el[2]);

  let inputTensor = tf.tensor(inputArray);
  let outputTensor = tf.tensor(outputArray);
  let inputMax = inputTensor.max();
  let inputMin = inputTensor.min();
  let outputMax = outputTensor.max();
  let outputMin = outputTensor.min();

  let normalisedInput = inputTensor.sub(inputMin).div(inputMax.sub(inputMin));
  let normalisedOutput = outputTensor
    .sub(outputMin)
    .div(outputMax.sub(outputMin));

  return {
    input: normalisedInput,
    // input2: normalisedInput2,
    output: normalisedOutput,
    inputMax,
    inputMin,
    outputMax,
    outputMin
  };
});
//----------------------------------------------------TRAIN

let x_train = tensorData.input;
let y_train = tensorData.output;
(async () => {
  for (let i = 0; i < 50; i++) {
    let res = await model.fit(x_train, y_train, {
      batchSize: 32,
      epochs: 100
    });
    console.log(res.history.loss[0]);
  }
  console.log("Training is Complete");
})().then(() => {
  //----------------------------------------------------TEST
  let arrayToTest = [[5, 5], [2, 20], [20, 20]];
  let testTensor = tf.tensor(arrayToTest);
  let normalisedTestTensor = testTensor
    .sub(tensorData.inputMin)
    .div(tensorData.inputMax.sub(tensorData.inputMin));

  const preds = model.predict(normalisedTestTensor);

  const unNormPreds = preds
    .mul(tensorData.outputMax.sub(tensorData.outputMin))
    .add(tensorData.outputMin);

  unNormPreds.dataSync().forEach((predictedOutput, i) => {
    console.log();
    let realInput = arrayToTest[i];
    let realOutput = arrayToTest[i][0] * arrayToTest[i][1];
    console.log(
      `input:${realInput} predicted:${predictedOutput.toFixed(
        2
      )} expected:${realOutput.toFixed(2)} difference:${Math.abs(
        ((predictedOutput - realOutput) / predictedOutput) * 100
      ).toFixed(2)}%`
    );
  });
});

---data.js
function input() {
  return [
    [4, 12],
    [2, 6],
    [3, 9],
    [4, 7],
    [5, 15],
    [4, 4],
    [7, 21],
    [3, 6],
    [9, 2],
    [10, 30],
    [11, 7],
    [4, 32],
    [13, 6],
    [2, 6],
    [45, 9],
    [16, 48],
    [17, 9],
    [18, 8],
    [4, 6]
  ];
}
function expectedOutput() {
  return [
    [48],
    [12],
    [27],
    [28],
    [75],
    [16],
    [147],
    [18],
    [18],
    [300],
    [77],
    [128],
    [78],
    [12],
    [405],
    [768],
    [153],
    [144],
    [24]
  ];
}
function normalizeInputAndOutput(input, expectedOutput) {
  let a = input.map(i => i[0]);
  let aMax = Math.max(...a);
  let aMin = Math.min(...a);
  let b = input.map(i => i[1]);
  let bMax = Math.max(...b);
  let bMin = Math.min(...b);
  let expected = expectedOutput.map(i => i[0]);
  let expectedMax = Math.max(...expected);
  let expectedMin = Math.min(...expected);
  let max = Math.max(...a, ...b, ...expected);
  let min = Math.min(...a, ...b, ...expected);
  console.log(max);
  console.log(min);
  let normalisedInput = input.map(e => [
    (e[0] - min) / (max - min),
    (e[1] - min) / (max - min)
  ]);
  let normalisedOutput = expectedOutput.map(e => [(e[0] - min) / (max - min)]);
  return {
    input: normalisedInput,
    output: normalisedOutput,
    max: max,
    min: min
  };
}
function restore(n, max, min) {
  return n * (max - min) + min;
}
function normalise(n, max, min) {
  return [(n[0] - min) / (max - min), (n[1] - min) / (max - min)];
}

//[[0.1, 0.1, 0.1], [0.3, 0.3, 0.3], [0.7, 0.7, 0.7]];
---index.html
<html>

<head>
  <title>
  </title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.12.0"> </script>
  <script src="data.js" type="text/javascript"> </script>
  <script src="main.js" type="text/javascript"> </script>
</head>

<body>Tensorflow JS Demo</body>

</html>
